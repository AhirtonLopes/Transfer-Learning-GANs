{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ahirtonlopes/anaconda3/lib/python3.6/site-packages/h5py/__init__.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.\n",
      "  from ._conv import register_converters as _register_converters\n",
      "Using TensorFlow backend.\n"
     ]
    }
   ],
   "source": [
    "from keras.datasets import mnist\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, LeakyReLU, BatchNormalization\n",
    "from keras.optimizers import Adam\n",
    "from keras import initializers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# load dataset\n",
    "\n",
    "(X_train, y_train), (X_test, y_test) = mnist.load_data()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\niCMAOPPMM4HCT7HFtMLr1VprrQXkyglg2223BWDjjTee7+tWXXXV9PjEE08sT+Yi07lzZyD33dp/\n//3Tc94qX2211YD871ux37MePXoAcMstt6Rpf/zjHwGYMWNGkbmuLG9B+t+vhx9+uJrZSW211VYA\nvPbaaxV5P7WgREQkSqqgREQkSlF28S211FLp8RZbbAHA4MGDgfwukUI+/PBDAAYMGADA/fffn54b\nM2YMkBvwB7jssstKkOP6teaaawKw5JJLVjkn8dhwww3TY+8yOvjggwFo27Ztes4sMwb82WefpWne\nBb3RRhsBcMABB6TnfELA+++/X45sR8N/57p161aR9/OlJwB33HEHkPtbECufeLTeeusB1e3i825X\ngLXXXhvI/V2A3Pe8LO9dtjuLiIi0QJQtqFtvvTU97tOnT1Gv9RaXT+0Npz37U8kmm2zSwhzWt65d\nu6bHffv2zTsXPt13794dgP/85z+VyViV+GScK664AoDevXun53wqeSHemt99993TNJ9G7eW44oor\npufC43r23HPPAYVbUP/973+BXEsnfHovNEFnu+22A3JTneuFt/r+8Y9/VDkn+b1WRx99NJDr0YLy\ntvjVghIRkSipghIRkShF1cXnsfV8tT00HoALu+wee+wxAK688so07csvvwTgzTffBGDq1KnpuZ13\n3rngPSVj++23B+DOO+9M07x7yw0cODA9njhxYmUyVmU9e/YE4He/+91Cr/3444/T41133RXInySx\n7rrrljh3tefmm28G4JFHHml0bu7cuQBMmjSpSffyKDJvv/02kFs/FQrf5/XXXy8us1USdm1W2+23\n394ozbuvyy2eUhAREQlE0YLy+Ho+eBrG1vPV40899RSQP2nCB0bDaeNe23/99dcAjBs3Lj3ng6xh\nC80nVSjSORx++OFA4afQkSNHArko8a1JGOmgoQkTJgC5lfVhJImw5eR8enlrNm/ePKBw+RTLJ6As\nv/zy873m888/T49LHO+wpMLJWx07dqxiTvI17EWB3N/qclMLSkREolS1FlQYwfj0008HcjX15MmT\n03NfffUVAHfffTcAs2bNSs898cQTef82VbiY8tRTTwVyCy1bm3Bq829/+1sgfzrvtGnTALj44osr\nm7GI+NTaY445BoBnn302PffRRx8BuenRCxPTk3GtCqOT+/+b8He6oX79+pU9T6UQTrtf0OepFP+u\n+uLc0BdffFGRPKgFJSIiUVIFJSIiUap4F98SSywB5E8N96atxykLY2f5tNByNXnXWGONstw3dr49\nRLh9SSGDBg0C4IUXXih3lqLlSxf69+/f4nv5FhzSNGHX+1lnnQXkT9X3yByFvPXWW0Bu6nrsNthg\ng0Zp77zzThVykuF/o8Nu6Q8++ADI/a0uN7WgREQkShVvQW2++eZA4Thce++9N9D8bcOl6fbYYw+g\ncFzCv//97+nxddddV7E81TLfbHDppZde4HU///nP8/775ZdfTo9jiLtWCd56P/TQQ4H82I8N+eJx\nWPCGhb4BobeyAJ588kkA5syZ0+y8Vlu5Nwb0JT3+9wDgkEMOAWC33XZrdP1FF10E5CZPlZtaUCIi\nEqWKt6CuvvpqID/ckLeYyt1y8vAhhaIitxb77LMPAJdffnmjcy+99BKQW7ALMH369MpkrAb4PmWd\nOnVK0/70pz8BhXsEFvR983GtI488Mk374YcfSpfZyITb3j/66KNAacd/R48eDcBtt91WsnvGoEOH\nDk26btNNNwVyf1fDVunqq68OwOKLLw7kj+v5dzRsZb766qtAblHzoovmqomxY8cW9wFaSC0oERGJ\nkiooERGJUkW6+HxjO8jF3QsHPL3JX27e1RK+t09FrWc+KA0Lnlb+ySefAPW/AWFThNOXfWKPl124\ngZt3jXiXXTjRwQeevWsw5N0m++67b5rmE1K+//77ln+AiHk3VFN2FVjYhoXO/8bsueeeaZrH76wV\nYTeb/4265ZZbADjnnHMW+Fqf7ORl6vEOAb755hsA3n33XQD+8pe/pOd8GU84vOK//x7DMFziU87N\nCQtRC0pERKJUkRZUWAP7QF0Yu+yBBx4o+Xv6guBCiytHjBiRHp999tklf+/YhBG2F/QUWmjiRGvj\n389w2u2wYcPyrrngggvSY/8ujRkzBsgf1PZz4QQBt9JKKwFw2WWXpWmffvopkL9/UczRt4vh+zUB\n7LTTTkBuOvMzzzyTnvv2228Xeq+jjjoqPe7bt2+Jclh9xx9/fHrse635lvYL0/C7895776XnXnnl\nlaLy4TEn/TvqPSvVoBaUiIhESRWUiIhEqWrbbYRdF76lRil4155vYuhbeUBu0O+qq65K08LtO+qN\nT0gptCLcDR8+PD0eP3582fMUo3BChHffhd8b54PuHp8QcivqvTvEoxdALmpEOOlhwIABQK7bz6On\nAAwZMgSA559/Pk274oorAJg6dWqj/NTqBB/vvrrkkkua9fqw276euvhC/v+9GnbZZZe8/15YvM5y\nUgtKRESiVLUWVCmnlntLAXJPvr179wbyWwi9evUq2XvWAt9Yr9B22D5wesQRR1QyS1Fp06YNkIsv\nBnDaaacBMHv27DTN47vdf//9QH4csi5dugBwww03ALkp6QAffvghAMcdd1ya5lHhPQZaOAjuK/x7\n9OiRpjXcWjvcJr3QRnKtgW/zLpXx8MMPV+291YISEZEoVaQFFS7I82OPCQdw0kknNeu+J598MgDn\nn39+mubbxnt/fri3VGuzwgorAIWnlt90001AfY/BLYxPp/VWE+QWNR577LFpmrdEt9lmGyA/fp4v\nDPWlFBdeeGF67s477wTyWz3Oo28//fTTaZof9+nTJ0076KCD8l7n3/mYhWN6Pv4ZLu1obnRxL3dF\n2G891IISEZEoqYISEZEoVaSLL4x958errLJKmnb99dcDuRhRU6ZMSc95t4pvbuZh5SEXRt5XUUNu\nVbp3YbVG3rUUxjFrKNwor7Xq169fozSfOBFOM/dpzeFW4w35NWFkiOZunzF06NCCx7HzzQXPPffc\nNG3XXXcF8id0FOrybMgjcoTbmPhWPYViG3q3YVMiUUjT+HDM+uuvn6YVG5WipdSCEhGRKFVtmrk/\nqUIuBpVPA/cBZID11ltvvvfwVoBP3YXCT8WtQTjV3jcr88kR4ULRG2+8EVDEcoBJkyYBuUW2kFvo\nHbbUnS/CffHFF9M0j302YcIEoL43HVwYn2pfKPbgGWeckR7PnDlzoffyltcWW2yRphXa8n3kyJEA\n3HzzzUD+3wJpGS/vBfXElJtaUCIiEiVVUCIiEqWKdPGFm7i99tprAGy11VaNrvOJEx07dmx0zidO\n+Gp+aP76qXq03HLLpcfhBBSAL774Ij0O1/y0djvssAOQvybPu5TC7WB88o7Hw6v3DQXLIYym0Vz+\n/+Sxxx5L0/xvgCZHlM+2226bHt91110VfW+1oEREJEoVaUF5FHHIbXEdrtT3yOOF+KpxHwT96KOP\nypFFaYV8sP7ee+9N08JjKY7HdQwjjB9++OFF3ePjjz8GchE9Ro8enZ677bbbgPzND6V8wghA1aIW\nlIiIRKni08x976dwT5dC27JLcd5///302Kff+8JJkUrw/anCrcv/+c9/AnDxxRenaR5d36fohxHb\nffcBXwIglef7nu2///5VzolaUCIiEilVUCIiEiUrtDp7vhebNf3iOpckSYtHEFWeOSrPkhubJEmX\nltxA5ZmnxeUJKtNQU37n1YISEZEoqYISEZEoqYISEZEoqYISEZEoqYISEZEoqYISEZEoFRtJYjIw\nsRwZqTFrlug+Ks8MlWfplaJMVZ45+o6WVpPKs6h1UCIiIpWiLj4REYmSKigREYmSKigREYmSKigR\nEYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmS\nKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigR\nEYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmS\nKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigREYmSKigR\nEYmSKigREYlSVSsoM+tvZoOrmYd6ovIsPZVpaak8S6vey7PsFZSZHWRmr5vZLDP7ysyeMrPty/2+\n88nLBDObk83LLDN7thr5aImYyjObn5PM7N9mNtvM3jOz9auVl+aKpUzNbI3gu+k/iZmdWum8tEQs\n5ZnNy2ZmNtrMppvZ52bWrxr5aInIynM7M/unmc00s/8rdz7KWkGZ2SnAtcClQEdgDeAmYO9yvu9C\n/CZJknbZn92qmI+ixVaeZvY74ChgL6Ad0B2YXI28NFdMZZokyafBd7Md8HPgR+ChSueluWIqz6z7\ngBeBDsCOwHFm1qNKeSlaTOVpZh2AR4GBwHLAAOAxM1u+bG+aJElZfoBlgVnA/gu4pj8wOPjvvwGT\ngOlkvlSdg3PdgHeBmcAXwGnZ9BWBx4FpwP+A0cAi83m/CUDXcn3mcv7EVp5kHm4+A3apdtnUS5kW\neO8/AS9Uu5xquTyBb4BODd7v7GqXVS2WJ5kH0HcapH0AHFWuMihnC2pbYEng4SJe8xSwHrAy8AYw\nJDh3B3BskiTLABsDI7LppwKfAyuRecI4B0gW8B5DzOxrM3vWzDYtIm/VFlt5rp792djMPst2811g\nZrU08Sa2Mm3oMODuIvJWbTGW57XAYWa2mJltkM3j80Xkr5piK0/L/jRM27iI/BWlnH9MVgAmJ0ky\nr6kvSJLkL0mSzEyS5DsyTwabmtmy2dNzgU5m1j5JkqlJkrwRpK8KrJkkydwkSUYn2aq9gIOBtYA1\ngReAZ8xsuaI/WXXEVp6rZ//djUxX1K+BPmS6/GpFbGWaMrNfkflj8WCRn6maYizPx4H9gDnA+8Ad\nSZK8VvxHq4rYyvNlYDUz65Ot8A8HfgYs1czPt1DlrKCmACua2aJNudjM2pjZ5Wb2sZnNINMdB5nm\nJ0AvMk3UiWY2ysy2zaYPBD4CnjWzT8zsrPm9R5IkY5IkmZMkyTdJklxGpkn7q+I/WlXEVp5zsv8O\nSJJkWpIkE4Bbs/esFbGVaehw4KEkSWY19cNEIKryzI6ZPA1cSKYl8lNgdzM7vhmfrRqiKs8kSaaQ\nGfs6BfgPsAeZ1ujnxX+0JipX3yG5/tP9FnBNf7L9p8ChwHvA2mSajcuRaWau2+A1iwEnA58VuF9n\n4L80cVwk+349ylUG9VyeZJ6avgN2CNJOBR6udlnVapkG17QlM4awc7XLqJbLE+gCTG2Q9kfg8WqX\nVS2WZ4FrFwUmAruXqwzK1oJKkmQ60A+40cz2MbOlss3CPc1sQIGXLEPmD94UMn/8LvUTZra4mR1s\nZssmSTIXmAH8kD3X3czWNTML0n9oeHPLTOH9ZfZeS5rZ6WSeLMaU9pOXR2zlmSTJN8ADwBlmtoyZ\nrQ4cTaZLpSbEVqaBnmRa9y+U4GNWTITl+UHmcjvIzBYxs1WA3sC40n3q8omwPDGzzbN5aA9cCXye\nJMkzpfvUDVTgKeBg4HVgNpnZJU8A2xWo/dsBw8nMMJlIZoA4AdYFFifTVJ9KpgBfA7bPvu5kMk3Z\n2WSamufPJx+dgf/LXjcF+DvQpdpPSbVantlr2wP3Z9/jMzK/TFbtMqrlMs1e/wxwUbXLpR7KE9g5\n+9rp2bz8GViq2mVUw+U5NFuW08k8oK5czs9u2TcVERGJSi1NCRYRkVZEFZSIiERJFZSIiERJFZSI\niERJFZSIiESpSSuUnZlpyl9WkiQNY1IVTeWZo/IsuclJkqzUkhuoPPO0uDxBZRpqyu+8WlAi9Wli\ntTNQZ1SeVaAKSkREoqQKSkREolTUGJS0Duuvn9u1/emnnwagTZs2AKy55ppVyZOItD5qQYmISJTU\ngpLUoEGDAOjdu3ea1qFDBwAef7xmgpSLSJ1QC0pERKKkCkpERKKkLr5WqmPHjgAMGzYsTdtmm20A\nCLdgefvttwE46qijKpg7ERG1oEREJFLRt6B8evOyyy4732tOOOGE9HippZYCYIMNNgDgD3/4Q3ru\nyiuvBKBPnz5p2rfffgvA5ZdfDsAFF1xQimxHy6eQe1n84he/aHTN2WefnR6//vrrAEyZMqUCuRNp\nmaWXXjo9HjlyJACrrbZamvbLX/4SgAkTJlQyW9JMakGJiEiUqtaCWmONNdLjxRdfHIDtttsOgO23\n3z49t9xyywHQq1evou7/+eefA3D99denaT179gRg5syZadq4ceMAGDVqVFH3r1U+bbxbt27zvcbL\nDuCFF14oe55EmsJbQiut1Dhm69SpUwH49a9/naZtueWWAIwfPz5NU09AbVELSkREoqQKSkREolTx\nLr7NNtsMgBEjRqRpC5oAUawff/wRgPPOOw+AWbNmpeeGDBkCwFdffZWmeddA2A1Qb8LYevfddx8A\nZo23Ytl3330BGD58eGUyVudOPfVUINeFDbDRRhsBcPDBBze6/v333wegc+fOFchdPDbeeOP0+MQT\nTwQKx3z073E4POB8klOnTp3SNP+Of/HFF2la+P+itfCJUIcccggAO+64Y3qu0HfttNNOA+DLL78E\n8odcBg8eDMCrr75answ2oBaUiIhEqeItqE8//RTIH6wspgUV1tzTpk0D8gdGv//+ewDuvffeFuWz\nnhx66KHpsT99PvnkkwD8/ve/T8+FT5rSNP406q2A8OnUJ+UUaq2Gi6HdeuutB8C7776bpoUtgnq1\n8847p8cLWhD+3XffAbmn+PC1Z511VqPrvYzvuuuuNK21TJII42led911AKy44opA/vfRp+KHE08G\nDhyYd6/wer/uwAMPLG2G50MtKBERiZIqKBERiVLFu/j+97//AXD66aenad27dwfgzTffBPLXLrm3\n3noLgF133TVNmz17NpA/0HfSSSeVOMe16+WXXwZyE1Mgt4L+5JNPBtStNz+rrrpqejx06FAA1lln\nnUbXefe0RzAIu0PGjh0LwBZbbNGk91xkkUXy7lXv+vfvD+T/LXB33303AF9//XWa5tFPwjT/bj/z\nzDNArhsrvO7BBx8sYa7jtOiimT/lXbp0AeDPf/5zes6j67z44osAXHTRRem5l156CYAlllgiTfvr\nX/8KwG677dbofTyyTKWoBSUiIlGqWiSJRx55JD32Kece4WHTTTdNz/mgqT89easp9M4776THxxxz\nTOkzW2P23ntvIDe9NByQ/9vf/gbkYhBKvq5duwL5T6A//elPm/z6cFLD5MmTgfyneo+GcOeddwKw\n+uqrN7pHOEminnlLsW3btmnaxIkTATj33HOB/CUhbt11102PzznnHCA3eB/+ffAWWmv4rvsU8ttv\nv73Rueeeew7ITZyYMWNGo2vCSRUNW05hZBlv2VaKWlAiIhKlKKKZN6zRp0+f3uiao48+GoAHHngg\nTfNFuZKLWQjwq1/9ar7X+cLk8KloQXxMr1Arwhf01ZMzzjgDWHCryac7A5x55pkAvPLKK0DhBd/h\n1GYvz0ItJx8fDJcF1DMfG9pjjz3SNG+B+sLb448/Pj3n431XX311mrbXXnsBubHtSy65JD138803\nlyPb0QjHkrwl6b0lN910U3rOgxYUajk5b7EW4ounIX/8rxLUghIRkSipghIRkShF0cXXkA9uQi5k\nvq/Q90FsgGeffbai+YrZDz/8kB57mfm05bAr1KeaFuJTz0N9+/YFCsdG81hzYXdVLU5bDweFfdv7\nQjwKStgFN2bMmKLeq1DXnvMYiD65ot750hHvHoVcF59HiAiXlVxzzTVA4Vh8vtHooEGDypPZiPTr\n1w/IdetBLoKOT7f3rmeAOXPm5L1+ySWXTI/9ux+WqS+VuPjii4HqxuZUC0pERKIUZQsqnCrqkyPe\neOMNIH/6r2+mFy4eu/HGG4HCsc7qWRgDzidJeMvJn/yh8dN5uIjXX9ejR49G9/f/J+Hkig022ADI\nXwjpMbp8unAt8JYg5BY1hnzBsz+lN7XVtPzyywP5kwB22GGHgveGXHzE1sInmxQavPfp+A899FCa\n5k/24e/2HXfcAeQvW6lH4SQonzgSloO3nPbZZ5/53sOn5/uuDpDrbQn57/OAAQNakOPSUAtKRESi\nFGULKvTxxx8DcMQRRwC5BY6QGwsIxwR88d8999wDFF7oV0+WWWYZANZee+1G53w/lzCy+0cffQTk\n9tYJw8z4At+wleXjfFdddRWQH3neF1iXcj+varjtttvSY19UGy51OOiggwCYNGlSUff1SPHhdGDn\ni8sPOOCANK3Y+9eLYlvbYUvTF/B/9tlnJc1TbMJ9rMKF386ngq+88soAHHnkkek57xHxiPvt2rVL\nz3krLGyNebT4QkERKk0tKBERiZIqKBERiZIVM5nAzKo+8yDcHtpXlO+yyy6Nrrv11luB/JXlpZwC\nnSRJ413oilSK8txzzz0BeOyxxxqdu/DCC/P+BejYsSOQm2zSrVu39NysWbOA/C5Bjxbhm+l5LD/I\nRfwOr/dp6cWKpTxb6je/+U167FGhF1tssTRt3rx5QG5KfxmjHYxNkqRLS25Q7vJs06YNAPfff3+a\n1qtXr/le/8QTTwD5ZVxBLS72CYZ8AAAFmUlEQVRPaH6ZhpMk3nvvPSB/k8FCE0ga8i7/MOK+/w6H\nESLCSP7l1JTfebWgREQkStFPkmjo7bffTo99gDl8ovJJFMceeyyQe/KH/EV/9WKTTTaZ77mw5eSG\nDRsG5CKdh3ySxKhRo9I0X7jq+8aErr32WqA+Y/I1VzjdudDTrA9mhxMzWitvOe27775p2oJaAK1t\n6Uho2rRp6bFPJX/88cfTtA4dOgC5SWXh4lrf8t7jFYYtVm8thWkxUQtKRESipApKRESiVHNdfCFv\n9oaD9L5hl2+BHK7c32mnnQAYOXJkZTJYAT54Gg58NoydFUaLWGuttfKuD6MoeNeer5ECuO++++Z7\nvXfxCVx66aVALv4hFN4OJuw+bU08MgTk1uj4hIiw684jxowbNy7vWsit8WntXn31VSB/kkRT+N/C\nMOqMf0c/+eSTEuWutNSCEhGRKNVcCyqcFLDffvsBsNVWW6Vp3nJy4fbZC4rkXevCp9AFDSb7E5Nf\nE5anx+wLox3/+9//BnJx+gptJtma+Qr/zTffHMhvNXkZ+yaFAB9++GEFcxePcClIw8k7vqEewA03\n3ADkJgKELajwd1mK17ZtW6Dwd1STJERERIoQfQvKI2afcMIJQP6U1FVWWWW+r/P9kcJYfPW4RbyP\nNxWKqedTxMMxKI/d5w477LD02MeZwlh8vjdXLe7zVC5hxPNDDjkEKLyEYejQoUB+9Oh6/A4uiI/7\nXn/99Y3OeYy4559/Pk3z32nf8yg0YcKE0mewFfGI57VELSgREYmSKigREYlSVF183rzv06dPmuZd\nez49emF880KPwffoo4+WMIfxmTt3LgDffPNNmuZdUL6xXlNX4M+cORPIxZADeOqpp0qSz3rg3aPh\nppk+Ucd5jD3IDfi3tm69kHd9hluy+FR7j4QQxirs3r173vXh8okwXpwUb/fdd692FoqmFpSIiESp\nai0oj6oN0KlTJyD3xLnhhhs26R6+YG3gwIFpmk8aaC1PrWPHjgXyW52nnHIKkBugLuTuu+8G4F//\n+lea9uabbwKtdzHpwvzkJz8BGreaIBcDrdBkgNas4bKG8NhbTuE25ddddx0AU6dOBXIL76Gskd9b\nhXXWWafaWSiaWlAiIhIlVVAiIhKlinTxeSh4yG0kGK7NaUrT8+WXXwbgqquuStN8Xv+cOXNKks9a\n5pu5NTyWlvMu5zAOofvggw+A3MaRkq9Q/Dyf7PDcc88BuSglIY8gUWgjTmme0aNHAwuPFxkTtaBE\nRCRKZWlB+WZ4Ht1g6623Ts/5QPOChFOmfdDZo0XPnj27ZPkUaYrzzz8fgN69ezc6N2jQIAAmTpxY\n0TzVCt+ePOSTTHwKuW+kB3DjjTcC+dElpDR8s9cwHqT3Xv3sZz9L02Kazq8WlIiIRKksLaiePXvm\n/VtIGJnYF+zNmzcPyB9nCrc6FqmUzp07p8ft27fPOxdu1z5ixIiK5akW+XIGj/oOuRapL6oPF9Nf\nc801Fcxd6+S9UZCbxu+BDQD69u0LxBE9Xi0oERGJkiooERGJkjU1ThuAmTX94jqXJIkt/KoFU3nm\nxFaeV1xxRXrs08t9IkS3bt3Sc+PHjy/VW5ba2CRJurTkBvp+5mlxeUIcZRp2WXvcza5du6Zpw4YN\nA3JT/cs1Ma0pv/NqQYmISJTUgmqm2J74a11s5RluUe4Lwnv16gXk4j1GTi2o0qqbFlTIW1PhJInj\njjsOgE022QQo32QJtaBERKRmqYISEZEoqYuvmWLrkqp1Ks+SUxdfadVlF181qYtPRERqVrGRJCYD\nCjoGa5boPirPDJVn6ZWiTFWeOfqOllaTyrOoLj4REZFKURefiIhESRWUiIhESRWUiIhESRWUiIhE\nSRWUiIhESRWUiIhESRWUiIhESRWUiIhESRWUiIhE6f8Bgcy9jCpROYIAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x182d8987f0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig = plt.figure()\n",
    "for i in range(10):\n",
    "    plt.subplot(2, 5, i+1)\n",
    "    x_y = X_train[y_train == i]\n",
    "    plt.imshow(x_y[0], cmap='gray', interpolation='none')\n",
    "    plt.title(\"Class %d\" % (i))\n",
    "    plt.xticks([])\n",
    "    plt.yticks([])\n",
    "    \n",
    "plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train.shape (60000, 28, 28)\n",
      "X_train reshape: (60000, 784)\n"
     ]
    }
   ],
   "source": [
    "print('X_train.shape', X_train.shape)\n",
    "\n",
    "# reshaping the inputs\n",
    "X_train = X_train.reshape(60000, 28*28)\n",
    "# normalizing the inputs (-1, 1)\n",
    "X_train = (X_train.astype('float32') / 255 - 0.5) * 2\n",
    "\n",
    "print('X_train reshape:', X_train.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# latent space dimension\n",
    "latent_dim = 100\n",
    "\n",
    "# imagem dimension 28x28\n",
    "img_dim = 784\n",
    "\n",
    "init = initializers.RandomNormal(stddev=0.02)\n",
    "\n",
    "# Generator network\n",
    "generator = Sequential()\n",
    "\n",
    "# Input layer and hidden layer 1\n",
    "generator.add(Dense(128, input_shape=(latent_dim,), kernel_initializer=init))\n",
    "generator.add(LeakyReLU(alpha=0.2))\n",
    "generator.add(BatchNormalization(momentum=0.8))\n",
    "\n",
    "# Hidden layer 2\n",
    "generator.add(Dense(256))\n",
    "generator.add(LeakyReLU(alpha=0.2))\n",
    "generator.add(BatchNormalization(momentum=0.8))\n",
    "\n",
    "# Hidden layer 3\n",
    "generator.add(Dense(512))\n",
    "generator.add(LeakyReLU(alpha=0.2))\n",
    "generator.add(BatchNormalization(momentum=0.8))\n",
    "\n",
    "# Output layer \n",
    "generator.add(Dense(img_dim, activation='tanh'))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 128)               12928     \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_1 (LeakyReLU)    (None, 128)               0         \n",
      "_________________________________________________________________\n",
      "batch_normalization_1 (Batch (None, 128)               512       \n",
      "_________________________________________________________________\n",
      "dense_2 (Dense)              (None, 256)               33024     \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_2 (LeakyReLU)    (None, 256)               0         \n",
      "_________________________________________________________________\n",
      "batch_normalization_2 (Batch (None, 256)               1024      \n",
      "_________________________________________________________________\n",
      "dense_3 (Dense)              (None, 512)               131584    \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_3 (LeakyReLU)    (None, 512)               0         \n",
      "_________________________________________________________________\n",
      "batch_normalization_3 (Batch (None, 512)               2048      \n",
      "_________________________________________________________________\n",
      "dense_4 (Dense)              (None, 784)               402192    \n",
      "=================================================================\n",
      "Total params: 583,312\n",
      "Trainable params: 581,520\n",
      "Non-trainable params: 1,792\n",
      "_________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "# prints a summary representation of your model\n",
    "generator.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Discriminator network\n",
    "discriminator = Sequential()\n",
    "\n",
    "# Input layer and hidden layer 1\n",
    "discriminator.add(Dense(128, input_shape=(img_dim,), kernel_initializer=init))\n",
    "discriminator.add(LeakyReLU(alpha=0.2))\n",
    "\n",
    "# Hidden layer 2\n",
    "discriminator.add(Dense(256))\n",
    "discriminator.add(LeakyReLU(alpha=0.2))\n",
    "\n",
    "# Hidden layer 3\n",
    "discriminator.add(Dense(512))\n",
    "discriminator.add(LeakyReLU(alpha=0.2))\n",
    "\n",
    "# Output layer\n",
    "discriminator.add(Dense(1, activation='sigmoid'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_5 (Dense)              (None, 128)               100480    \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_4 (LeakyReLU)    (None, 128)               0         \n",
      "_________________________________________________________________\n",
      "dense_6 (Dense)              (None, 256)               33024     \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_5 (LeakyReLU)    (None, 256)               0         \n",
      "_________________________________________________________________\n",
      "dense_7 (Dense)              (None, 512)               131584    \n",
      "_________________________________________________________________\n",
      "leaky_re_lu_6 (LeakyReLU)    (None, 512)               0         \n",
      "_________________________________________________________________\n",
      "dense_8 (Dense)              (None, 1)                 513       \n",
      "=================================================================\n",
      "Total params: 265,601\n",
      "Trainable params: 265,601\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "# prints a summary representation of your model\n",
    "discriminator.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Optimizer\n",
    "optimizer = Adam(lr=0.0002, beta_1=0.5)\n",
    "\n",
    "discriminator.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['binary_accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "discriminator.trainable = False\n",
    "\n",
    "d_g = Sequential()\n",
    "d_g.add(generator)\n",
    "d_g.add(discriminator)\n",
    "d_g.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['binary_accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "sequential_1 (Sequential)    (None, 784)               583312    \n",
      "_________________________________________________________________\n",
      "sequential_2 (Sequential)    (None, 1)                 265601    \n",
      "=================================================================\n",
      "Total params: 848,913\n",
      "Trainable params: 581,520\n",
      "Non-trainable params: 267,393\n",
      "_________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "# prints a summary representation of your model\n",
    "d_g.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch = 1/100, batch = 458/937, d_loss=0.717, g_loss=1.413                                                                                                     \r"
     ]
    }
   ],
   "source": [
    "epochs = 100\n",
    "batch_size = 64\n",
    "smooth = 0.1\n",
    "\n",
    "real = np.ones(shape=(batch_size, 1))\n",
    "fake = np.zeros(shape=(batch_size, 1))\n",
    "\n",
    "d_loss = []\n",
    "d_g_loss = []\n",
    "\n",
    "for e in range(epochs + 1):\n",
    "    for i in range(len(X_train) // batch_size):\n",
    "        \n",
    "        # Train Discriminator weights\n",
    "        discriminator.trainable = True\n",
    "        \n",
    "        # Real samples\n",
    "        X_batch = X_train[i*batch_size:(i+1)*batch_size]\n",
    "        d_loss_real = discriminator.train_on_batch(x=X_batch, y=real * (1 - smooth))\n",
    "        \n",
    "        # Fake Samples\n",
    "        z = np.random.normal(loc=0, scale=1, size=(batch_size, latent_dim))\n",
    "        X_fake = generator.predict_on_batch(z)\n",
    "        d_loss_fake = discriminator.train_on_batch(x=X_fake, y=fake)\n",
    "         \n",
    "        # Discriminator loss\n",
    "        d_loss_batch = 0.5 * (d_loss_real[0] + d_loss_fake[0])\n",
    "        \n",
    "        # Train Generator weights\n",
    "        discriminator.trainable = False\n",
    "        d_g_loss_batch = d_g.train_on_batch(x=z, y=real)\n",
    "   \n",
    "        print(\n",
    "            'epoch = %d/%d, batch = %d/%d, d_loss=%.3f, g_loss=%.3f' % (e + 1, epochs, i, len(X_train) // batch_size, d_loss_batch, d_g_loss_batch[0]),\n",
    "            100*' ',\n",
    "            end='\\r'\n",
    "        )\n",
    "    \n",
    "    d_loss.append(d_loss_batch)\n",
    "    d_g_loss.append(d_g_loss_batch[0])\n",
    "    print('epoch = %d/%d, d_loss=%.3f, g_loss=%.3f' % (e + 1, epochs, d_loss[-1], d_g_loss[-1]), 100*' ')\n",
    "\n",
    "    if e % 10 == 0:\n",
    "        samples = 10\n",
    "        x_fake = generator.predict(np.random.normal(loc=0, scale=1, size=(samples, latent_dim)))\n",
    "\n",
    "        for k in range(samples):\n",
    "            plt.subplot(2, 5, k+1)\n",
    "            plt.imshow(x_fake[k].reshape(28, 28), cmap='gray')\n",
    "            plt.xticks([])\n",
    "            plt.yticks([])\n",
    "\n",
    "        plt.tight_layout()\n",
    "        plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# plotting the metrics\n",
    "plt.plot(d_loss)\n",
    "plt.plot(d_g_loss)\n",
    "plt.title('Model loss')\n",
    "plt.ylabel('Loss')\n",
    "plt.xlabel('Epoch')\n",
    "plt.legend(['Discriminator', 'Adversarial'], loc='center right')\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
